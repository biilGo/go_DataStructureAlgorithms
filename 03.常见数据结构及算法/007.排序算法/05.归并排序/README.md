# 归并排序
归并排序是一种分治策略的排序算法,它是一种比较特殊的排序算法,通过递归地先使每个子序列有序,再将两个有序的序列进行合并成一个有序的序列.

归并排序首先由著名的现代计算机之父`John_von_Neumann`在1945年发明,被用在了`EDVAC`足足用墨水写了23页的排序程序.

# 算法介绍
我们先介绍两个有序的数组合并成一个有序数组的操作.

1. 先申请一个辅助数组,长度等于两个有序数组长度的和
2. 从两个有序数组的第一位开始,比较两个元素,哪个数组的元素更小,那么该元素添加进辅助数组,然后该数组的元素变更为下一位,继续重复这个操作,直至数组没有元素
3. 返回辅助数组

举一个例子:
```
有序数组A：[3 8 9 11 13]
有序数组B：[1 5 8 10 17 19 20 23]
[] 表示比较的范围。

因为 1 < 3，所以 1 加入辅助数组
有序数组A：[3 8 9 11 13]
有序数组B：1 [5 8 10 17 19 20 23] 
辅助数组：1

因为 3 < 5，所以 3 加入辅助数组
有序数组A：3 [8 9 11 13]
有序数组B：1 [5 8 10 17 19 20 23] 
辅助数组：1 3

因为 5 < 8，所以 5 加入辅助数组
有序数组A：3 [8 9 11 13]
有序数组B：1 5 [8 10 17 19 20 23] 
辅助数组：1 3 5

因为 8 == 8，所以 两个数都 加入辅助数组
有序数组A：3 8 [9 11 13]
有序数组B：1 5 8 [10 17 19 20 23] 
辅助数组：1 3 5 8 8

因为 9 < 10，所以 9 加入辅助数组
有序数组A：3 8 9 [11 13]
有序数组B：1 5 8 [10 17 19 20 23] 
辅助数组：1 3 5 8 8 9

因为 10 < 11，所以 10 加入辅助数组
有序数组A：3 8 9 [11 13]
有序数组B：1 5 8 10 [17 19 20 23] 
辅助数组：1 3 5 8 8 9 10

因为 11 < 17，所以 11 加入辅助数组
有序数组A：3 8 9 11 [13]
有序数组B：1 5 8 10 [17 19 20 23] 
辅助数组：1 3 5 8 8 9 10 11

因为 13 < 17，所以 13 加入辅助数组
有序数组A：3 8 9 11 13
有序数组B：1 5 8 10 [17 19 20 23] 
辅助数组：1 3 5 8 8 9 10 11 13

因为数组A已经没有比较元素，将数组B剩下的元素拼接在辅助数组后面。
结果：1 3 5 8 8 9 10 11 13 17 19 20 23
```

将两个有序数组进行合并,最多进行`n`次比较就可以生成一个新的有序数组,`n`是两个数组长度比较大的那个.

归并操作最坏的时间复杂度:`O(n)`,其中`n`是较长数组的长度

归并操作最好的时间复杂度:`O(n)`,其中`n`是较短数组的长度.

正是利用这个特点,归并排序先排序较小的数组,再将有序的小数组合并形成更大有序的数组.

归并排序有两种递归做法,一种是自顶向下,一种是自底向上.

### 自顶向下归并排序
从一个大数组开始,不断地往下切分,如图:
![merge_sort.png](./assets/merge_sort.png)

从上往下进行递归,直到切分的小数组无法切分了,然后不断地对这些有序数组进行合并.

每次都是一分为二,特别均匀,所以最差和最坏时间复杂度都一样,归并操作的时间复杂度:`O(n)`,因此总的时间复杂度为:`T(n)=2T(n/2)+O(n)`,根据主定理公式可以直到时间复杂度为:`O(nlogn)`.
```
归并排序，每次归并操作比较的次数为两个有序数组的长度： n/2
T(n) = 2*T(n/2) + n/2
T(n/2) = 2*T(n/4) + n/4
T(n/4) = 2*T(n/8) + n/8
T(n/8) = 2*T(n/16) + n/16
...
T(4) = 2*T(2) + 4
T(2) = 2*T(1) + 2
T(1) = 1
进行合并也就是：
T(n) = 2*T(n/2) + n/2
     = 2^2*T(n/4)+ n/2 + n/2
     = 2^3*T(n/8) + n/2 + n/2 + n/2
     = 2^4*T(n/16) + n/2 + n/2 + n/2 + n/2
     = ...
     = 2^logn*T(1) + logn * n/2
     = 2^logn + 1/2*nlogn
     = n + 1/2*nlogn
因为当问题规模 n 趋于无穷大时 nlogn 比 n 大，所以 T(n) = O(nlogn)。
因此时间复杂度为：O(nlogn)。
```

因为不断地递归,程序栈层数会有`logn`层,所以递归栈的空间复杂度:`O(logn)`,对于排序十几亿个整数,也只要:`log(100 0000 0000)=29.897`,占用的堆栈层数最多30层忧.

### 自底向上归并排序
从小数组开始排序,不断地合并形成更大的有序数组
![merge_sort2.png](./assets/merge_sort2.png)

时间复杂度和自顶向上归并排序一样也都是`O(nlogn)`

因为不需要使用递归,没有程序栈占用,因此递归栈的空间复杂度为:`O(1)`