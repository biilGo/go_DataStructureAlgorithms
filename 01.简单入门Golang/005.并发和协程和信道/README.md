# 并发、协程和信道
go语言提供了go关键字以及名为chan的数据类型,以及一些标准库的并发锁等

## 并发介绍
我们写程序时,可能会读取一个几千兆的日志,读磁盘可能需要读几十秒钟,我们不可能一直等他,因为虽然磁盘IO繁忙,但是处理器CPU很空闲,我们可以并发地开另一条路去处理其他逻辑.

在操作系统层面,出现了多进程和多线程的概念,一个处理器会在一个时间片里执行一个进程,当时间片用完了或者发生了中断比如进程抢占事件,当前进程上下文会被保存,然后处理器开始处理另外一个进程,这样频繁地切换执行,切换和执行的速度特别快,就产生了貌似程序们都在同时执行,其实还是串行执行,这种叫并发,在多核处理器上,进程可以调度到不同的处理器,时间片轮询也只是针对每一个处理器,同一时间在两个处理器上执行的两个进程,它们是实在的同时,这种叫并行,一般情况下,我们统称并发.

进程是计算机资源分配的最小单位,进程是对处理器资源,虚拟内存的抽象

虚拟内存是对主存资源和文件的抽象,文件是对IO设备的抽象

其中,cpu\mem\IO设备就是我们所说的处理器,内存\硬盘

线程是计算机调度的最小单位,也就是CPU大脑调度的最小单位,同个进程下的线程可以共享同个进程分配的计算机资源

同个进程下的线程间切换需要CPU切换上下文,但不需要创建新的虚拟内存空间,不需要内存管理单元切换上下文,比不同进程切换会显得更轻量.

综上所述,实际并发的是线程,每个进程都有一个主线程,因为线程是调度的最小单位,你可以只有一个线程,但是你也可以创建多个线程,线程调度需要CPU来切换,需要内核层的上下文切换,如果你跑A线程,然后切到B线程,内核调用开始,cpu需要对A线程的上下文保留,然后切到B线程,然后控制权交给你的应用层调度,进程切换也需要内核来切换,因为从C进程的主线程切换到D进程的主线程.

事实上,进程和线程只是概念上的划分,在操作系统内部,只用了一个数据结构来表示,里面有pid:进程ID,tgid:线程属于的线程组ID,如图:
![进程与线程](./assets/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.png)

每一个进程\线程都有一个pid,如果它是主线程,那么tgid=pid,从一个主线程fork出来的另一个进程的主线程pid,tgid都变了,而new thread出来的线程,除了pid变了,tgid不变

进程间还要通讯,因为它们资源不共享,这个时候需要用IPC,常用的有信号量,共享内存,套接字等

而同个进程多个线程共享资源,通讯起来比进程容易多了,因为它们共享了虚拟内存的空间,直接就可以读取内存,现在很多编程语言都有这种线程库实现

至于IO多路复用,其实就是维持一个线程队列,然后让一个线程或多个线程,去队列里拿任务去完成.因为线程的数量是有限的,而且线程间通讯需要点资源,内核也要频繁切换上下文,干脆就弄一个池,有任务就派个小弟出去.

只有一个线程的IO多路复用,典型的redis和nodejs,根本不需要切换到上下文,一个线程走天下,而多个线程的IO多路复用,就是go协程的实现方式了,协程自己管理线程,把线程控制到一定的数量,然后构造一个规则状态机来调度任务

## 协程和go关键字

## 信道chan

## 锁实现并发安全