# 包、变量和函数
golang语言只有小括号和大括号,不需要使用逗号来分割代码,只有一种循环`for`

## 工程管理:包机制
每一个大型的软件工程项目,都需要进行工程管理.工程管理的一个环节就是代码层次的管理.

包,也称为库,如代码的一个包,代码的一个库,英文:Library或者Package.比如:我们常常听到某程序员说:嘿.X哥,我知道github上有一个更好用的数据加密库,几千颗星

在高级语言层次,也就是代码本身,各种语言发明了包机制来更好的管理代码,将代码按功能分类归属于不同的包.

golang语言目前的包管理新机制叫`go mod`,我们的项目结构是:
```
├── diy
│   └── diy.go
└── main.go
```

每一个`*.go`源码文件,必须属于一个包,假设包名叫`diy`,在代码最顶端必须有`package diy`,在此之前不能有其他代码片段,如`diy/diy.go`文件中:
```
// 包名
package diy
// 结构体
type Diy struct {
    A int64   // 大写导出成员
    b float64 // 小写不可以导出
}
```

作为执行入口的源码,则强制包名必须为`main`,入口函数为`func main()`,如`main.go`文件中:
```
// Golang程序入口的包名必须为 main
package main // import "golang"
// 导入其他地方的包，包通过 go mod 机制寻找
import (
    "fmt"
    "golang/diy"
)
```

在入口文件`main.go`文件夹下执行以下命令:`go mod init`

该命令会解析`main.go`文件的第一行`package main // import "golang`,注意注释`//`后面的`import "golang"`会生成`go.mod`文件:
```
module golang
go 1.13
```

golang编译器会将这个项目认为是包golang,这是整个项目最上层的包,而底下的文件夹diy作为package diy,包名全路径是`golang/diy`

接着,main.go为了导入包,使用import():
```
// 导入其他地方的包，包通过 go mod 机制寻找
import (
    "fmt"
    "golang/diy"
)
```

可以看到导入了官方的包和我们自己定义的包,官方的包会自动寻找到,不需要任何额外的处理,而自己的包会在当前项目往下找.

在包diy中,我们定义了一个结构体和函数:
```
// 结构体
type Diy struct {
    A int64   // 大写导出成员
    b float64 // 小写不可以导出
}
// 小写函数，不能导出，只能在同一包下使用
func sum(a, b int64) int64 {
    return a + b
}
```

对于包中大小写函数或者结构体中小写的字段,不能导出,其他包不能使用它,golang用它实现了私有或公有控制,毕竟有些包的内容我们不想在其他包中被使用,类似Java的private关键字

最后,golang的程序入口统一在包的main中的main函数,执行程序时是从这里开始的
```
package main
import "fmt"
// init函数在main函数之前执行
func init() {
    // 声明并初始化三个值
    var i, j, k = 1, 2, 3
    // 使用格式化包打印
    fmt.Println("init hello world")
    fmt.Println(i, j, k)
}
// 程序入口必须为 main 函数
func main() {
}
```

有个必须注意的是函数`init()`会在每个包被导入之前执行,如果导入了多个包,那么会根据包导入的顺序先后执行init(),再回到执行函数main()

## 变量
Golang语言可以先声明变量,再赋值,也可以直接创建一个带值的变量.
```
// 声明并初始化三个值
var i, j, k = 1, 2, 3
// 声明后再赋值
var i int64
i = 3
// 直接赋值，创建一个新的变量
j := 5
```

可以看到`var i int64`数据类型是在变量的后面而不是前面,这是golang语言与其他语言最大的区别之一.

同时,作为一门静态语言,golang在编译前还会检查哪些变量和包未被引用,强制禁止游离的变量和包,从而避免某些人类低级错误.如:
```
package main
func main(){
    a := 2
}
```

变量定义后,如果没有赋值,那么存在默认值,我们也可以定义常量,只需加关键字`const`,如:`const s = 2`

常量一旦定义就不能修改

## 基本数据类型
数据类型基本有整数，浮点数，字符串，布尔值，数组，切片和字典

1. 布尔值:`bool`
2. 整数:`int`,`int32`,`int64`
3. 浮点数:`float32`,`float64`
4. 字符:`string`
5. 数组,切片,字典

没有声明具体变量类型的时候,会自动识别类型,把整数认为是int类型,把带小数点的认为是`float64`类型:

`a := 3` // int
`b := 6.0` // float64

所以当你需要使用确切的int64或float32类型时,需要这么做:
```
var a int64 = 3
var b float64 = 6.0
```

golang有数组类型的提供,但是一般不使用,因为数组不可变长,当你把数组大小定义好了,就在也无法变更大小.所以go语言造出了可变长数组:切片,将数组的容量大小去掉就变成了切片,可以像切东西一样,自动调整大小,可以切一部分,或者把两部分拼起来.
```
d := [3]string{"1", "2", "3"}         // array，基本不用到
e := []int64{1, 2, 3}                 // slice
```

切片可以像数组一样按下标取值,放值,也可以追加值:
```
// 切片放值
e[0] = 9
// 切片增加值
e = append(e, 3)
```

切片追加一个值3进去需要使用`append`关键字,然后将结果再赋值给自己本身,这是go语言与其他语言最大的区别之一,实际切片底层有个固定大小的数组,当数组容量不够时会生成一个新的更大的数组.

同时,因为日常开发中,我们经常将两个数据进行映射,类似于查字典一样,先查字母再翻页,所以字典`map`开发使用频率极高,所以go自动提供了这一数据类型,这是go语言与其他原因呢最大的区别之一.

字典存储了一对对的键值:
```
    // 增加map键值
    f["f"] = 5
    // 查找map键值
    v, ok := f["f"]
    fmt.Println(v, ok)
    v, ok = f["ff"]
    fmt.Println(v, ok)
```

## slice和map的特殊说明
键值结构字典:`map`使用前必须初始化
```
     m := map[string]int64{}
     m1 = make(map[string]int64)
```

如果不对字典进行初始化,作为引用类型,它是一个`nil`空引用,你使用空引用,往字典里添加键值对,将会报错

而切片结构`slice`不需要初始化,因为添加值时是使用`append`操作,内部会自动初始化,如:
```
    var ll []int64
    fmt.Printf("%#v\n", ll)
    ll = append(ll, 1)
    fmt.Printf("%#v\n", ll)
```

同时切片有以下特征:
```
    ll = append(ll, 2, 3, 4, 5, 6)
    fmt.Printf("%#v\n", ll)
    ll = append(ll, []int64{7, 8, 9}...)
    fmt.Printf("%#v\n", ll)
    fmt.Println(ll[0:2])
    fmt.Println(ll[:2])
    fmt.Println(ll[0:])
    fmt.Println(ll[:])
```

内置语法`append`可以传入多个值,将多个值追加进切片,并且可以将另外一个切片`[]int64{7, 8, 9}...`用三个点表示遍历出里面的值,把一个切片中的值追加进另一个切片

再切片后面加三个点`...`表示虚拟的创建若干变量,将切片里面的值赋予这些变量,再将变量传入函数.

我们取切片的值,除了可以通过下标取一个值,也可以取范围:`[下标起始:下标截止(不包括取该下标的值)]`,如`[0:2]`表示取出下标为`0和1`的值,总共有两个值,再比如`[0:4]`表示取出下标为`0,1,2,3`的值,如果下标取值,下标超出实际容量,将会报错

如果下标起始等于下标`0`,那么可以省略,如`[:2]`如果下标截止省略,如`[2:]`表示从下标`2`开始,取后面所有的值,这个表示`[:]`本身没有作用,它就表示切片本身

## 函数
我们可以把经常使用的代码片段封装成一个函数,方便复用:
```
// 函数，两个数相加
func sum(a, b int64) int64 {
    return a + b
}
```

go定义函数使用的关键字是`func`,后面带着函数名`sum(a, b int64) int64`表示函数`sum`传入两个`int64`整数`a`和`b`,输出值也是一个`int64`整数

使用时:
```
    // 定义 int64 变量
    var h, i int64 = 4, 6
    // 使用函数
    sum := sum(h, i)
    fmt.Printf("sum(h+i),h=%v,i=%v,%v\n", h, i, sum)
```

变量是有作用域的,作用域主要约束在各级大括号`{}`里面,所以函数里面的变量和函数体外的变量是没有关系的,互相独立