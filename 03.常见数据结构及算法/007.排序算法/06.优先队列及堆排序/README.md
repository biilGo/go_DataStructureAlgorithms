# 优先队列及堆排序
堆排序右威尔士-加拿大计算机科学家`J. W. J. Williams`在1964年发明,它利用了二叉堆的性质实现了排序,并证明了二叉堆数据结果的可用性.同年,美国藉计算机科学家`R. W. Floyd`在其数排序研究的基础上,发布了一个改进的更好的原地排序的堆排序版本

堆排序属于选择类排序算法

## 优先队列
优先队列是一种能完成以下任务的队列:插入一个数值,取出最小或最大的数值(获取数值,并且删除)

优先队列可以用二叉树来实现,我们称这种结构为二叉堆

最小堆和最大堆是二叉堆的一种,是一棵完全二叉树(一种平衡树).

最小堆的性质:
1. 父节点的值都小于左右儿子节点
2. 这是一个递归的性质

最大堆的性质:
1. 父节点的值都大于左右儿子节点
2. 这是一个递归的性质

最大堆和最小堆实现方式一样,只不过根节点一个是最大的,一个是最小的.

### 最大堆特征
最大堆实现细节(两个操作):
1. push:向堆中插入数据时,首先在堆的末尾插入数据,如果该数据比父节点还大,那么交换,然后不断向上提升,直到没有大小颠倒为止.
2. pop:从堆中删除最大值时,首先把最后一个值复制到根节点上,并且删除最后一个数值,然后和儿子节点比较,如果值小于儿子,与儿子节点交换,然后不断向下交换,直到没有大小颠倒为止.在向下交换过程中,如果有两个儿子都大于自己,就选择较大的

最大堆有两个核心操作,一个是上浮,一个是下沉,分别对应`push`和`pop`

### 上浮操作
我们要往堆里`push`一个元素`15`,我们先把`X=15`放到树最尾部,然后进行上浮操作.

因为`15`大于其父节点`8`,所以与父亲替换.

操作一次`push`的最好时间复杂度`O(1)`,因为第一个上浮时如果不大于父亲,那么就结束了.最坏的时间复杂度`O(logn)`,相当于每次都大于父亲,会一直上浮到根节点,翻转次数等于树的高度,而树的高度等于元素个数的对数:`log(n)`

### 下沉操作
我们现在要将堆顶的元素`pop`出,我们先将根节点移除,然后将最尾部的节点`4`放在根节点上.接着堆根节点`4`进行下沉操作,与其两个儿子节点比较,发现较大的儿子节点`8`比`4`大,那么根节点`4`与其儿子节点`8`交换位置,向下翻转,这样一直向下翻转就维持了最大堆的特征.

操作一次`pop`最好的时间复杂度:`O(1)`,因为第一次比较时根节点就是最大的,最坏时间复杂度仍然是树的高度:`O(logn)`

### 时间复杂度分析
构建一个最大堆,从空堆开始,每次添加元素到尾部后,需要向上翻转,最坏翻转次数是:
```
第一次添加元素翻转次数：log1
第二次添加元素翻转次数：log2
第三次添加元素翻转次数：不大于log3的最大整数
第四次添加元素翻转次数：log4
第五次添加元素翻转次数：不大于log5的最大整数
...
第N次添加元素翻转次数：不大于logn的最大整数
近似 = log(1)+log(2)+log(3)+...+log(n) = log(n!)
```

从一个最大堆,逐一移除堆顶元素,然后将堆尾元素置于堆顶后,最坏翻转次数是:
```
第一次移除元素恢复堆时间复杂度：logn
第二次移除元素恢复堆时间复杂度：不大于log(n-1)的最大整数
第三次移除元素恢复堆时间复杂度：不大于log(n-2)的最大整数
...
第N次移除元素恢复堆时间复杂度：log1
近似 = log(1)+log(2)+log(3)+...+log(n) = log(n!)
```

### 最大堆实现
程序`Heap`

## 普通堆的实现
根据最大堆,堆顶元素一直是最大的元素特征,可以实现堆排序

先构建一个最小堆,然后依次把根节点元素`pop`出即可.
```
func main() {
    list := []int{5, 9, 1, 6, 8, 14, 6, 49, 25, 4, 6, 3}
    // 构建最大堆
    h := NewHeap(list)
    for _, v := range list {
        h.Push(v)
    }
    // 将堆元素移除
    for range list {
        h.Pop()
    }
    // 打印排序后的值
    fmt.Println(list)
}
```