# 结构体和方法
## 值,指针和引用

## 结构体
有了基本的数据类型,还远远不够,所以go支持我们定义自己的数据类型,结构体:
```
// 结构体
type Diy struct {
    A int64   // 大写导出成员
    b float64 // 小写不可以导出
}
```

结构体的名字为`Diy`使用`type 结构体名字 struct`来定义

结构体里面有一些成员A和B,和变量定义一样类型int64和float64放在后面,不需要任何符号分隔,只需要换行即可,结构体里面小写的成员,在包外无法使用,也就是不可导出.

使用结构体时:
```
    // 新建结构体，值
    g := diy.Diy{
        A: 2,
        //b: 4.0, // 小写成员不能导出
    }
    // 新建结构体，引用
    k := &diy.Diy{
        A: 2,
    }
    // 新建结构体，引用
    m := new(diy.Diy)
    m.A = 2
```

可以按照基本数据类型的样子使用结构体,上述创立的:
```
    g := diy.Diy{
        A: 2,
        //b: 4.0, // 小写成员不能导出
    }
```

是一个值类型的结构体

你可以使用结构体前面加一个&或者使用new来创建一个引用类型的结构体,如:
```
    // 新建结构体，引用
    k := &diy.Diy{
        A: 2,
    }
    // 新建结构体，引用
    m := new(diy.Diy)
    m.A = 2
```

引用和值类型的结构体有何区别?

我们知道函数内和函数外的变量是独立的,当传参数进函数的时候,参数是值拷贝,函数里的变量被约束在函数体内,就算修改了函数里传入的变量的值,函数外也发现不了.

但引用类型的变量,传入函数时,虽然也是传值,但拷贝的是引用类型的内存地址,可以说拷贝一个引用,这个引用指向了函数体外的某个结构体,使用这个引用在函数里修改结构体的值,外面函数也会发现.

如果传入的不是引用类型的结构体,而是值类型的结构体,那么会完整拷贝一份结构体,该结构体和原来的结构体就没有关系了

内置的数据类型切片slice和字典map都是引用类型,不需要任何额外操作,所以传递这两种类型作为函数参数,是比较危险的,开发的时候需要谨慎操作.

## 方法
结构体可以和函数绑定,也就是说这个函数只能被该结构体使用,这种函数称为结构体方法:
```
// 引用结构体的方法，引用传递，会改变原有结构体的值
func (diy *Diy) Set(a int64, b float64) {
    diy.A = a
    diy.b = b
    return
}
// 值结构体的方法，值传递，不会改变原有结构体的值
func (diy Diy) Set2(a int64, b float64) {
    diy.A = a
    diy.b = b
    return
}
```

只不过在以前函数的基础上`func Set(a int64, b float64)`,变成了`func (diy *Diy) Set(a int64, b flaot64)`,只不过在函数里面可以是u用结构体变量diy里面的成员

上面表示值类型的结构体diy Diy可以使用Set2方法,引用类型的结构体`diy *Diy`可以使用Set方法.

如果是这样的话,我们每次使用结构体方法时,都需注意结构体是值还是引用类型,幸运的是go操碎了心,每次使用一个结构体调用方法,都会自动将结构体进行类型转换,以适配方法
```
    // 新建结构体，值
    g := diy.Diy{
        A: 2,
        //b: 4.0, // 小写成员不能导出
    }

    g.Set(1, 1)
    fmt.Printf("type:%T:%v\n", g, g) // 结构体值变化

    g.Set2(3, 3)
    fmt.Printf("type:%T:%v\n", g, g) // 结构体值未变化

    // 新建结构体，引用
    k := &diy.Diy{
        A: 2,
    }

    k.Set(1, 1)
    fmt.Printf("type:%T:%v\n", k, k) // 结构体值变化
    k.Set2(3, 3)
    fmt.Printf("type:%T:%v\n", k, k) // 结构体值未变化
```

结构体g是值类型,本来不能调用Set方法,但是go帮忙转换了我们毫无感知,然后值类型就变成了引用类型,同理,k是引用类型,照样可以使用Set2方法

前面我们也说过,函数传入引用,函数里修改该引用对应的值,函数外也会发现

结构体的方法也是一样,不过范围扩散了结构体本身,方法里可以秀嘎结构体本身,但是如果结构体是值,那么修改后,外面的世界是发现不了的

## 关键字new和make
关键字new主要用来创建一个引用引用类型的结构体,只有结构体可以用.

关键字make是用来创建和初始化一个切片或者字典,我们可以直接赋值来使用:
```
    e := []int64{1, 2, 3}                 // slice
    f := map[string]int64{"a": 3, "b": 4} // map
```

但是这种直接赋值相对粗暴,因为我们使用时可能不知道数据在哪里,数据有多少.

所以我们在创建切片和字典时,可以指定容量大小
```
    s := make([]int64, 5)
    s1 := make([]int64, 0, 5)
    m1 := make(map[string]int64, 5)
    m2 := make(map[string]int64)
    fmt.Printf("%#v,cap:%#v,len:%#v\n", s, cap(s), len(s))
    fmt.Printf("%#v,cap:%#v,len:%#v\n", s1, cap(s1), len(s1))
    fmt.Printf("%#v,len:%#v\n", m1, len(m1))
    fmt.Printf("%#v,len:%#v\n", m2, len(m2))
```

切片可以使用`make([],占用容量大小,全部容量大小)`来定义,你可以创建一个容量为5,但是实际容量为0的切片`make([]int64,0,5)`预留了5个空间,这样当你切片append时,不会因为容量不足而内部去分配空间,节省了时间.

如果你省略了后面的参数和`make([]int64,5)`那么其等于`make([]int64,5,5)`因为这时全部容量大小就等于占用容量大小.内置语言cap和len可以查看全部容量大小,已经占用的容量大小

同理,字典也可以指定容量,使用make([].容量大小)但是他们没有所谓的占用容量,它去掉了这个特征,因为我们使用切片
,可能需要5个空白的初始值,但是字典没有键的情况下,预留初始值也没有作用.省略容量大小,表示创建一个容量为0的键值结构,当赋值时会自动分配空间

## 内置语法和函数,方法的区别
函数是代码片段的一个封装,方法是将函数和结构体绑定

但是go里面有一些内置语法,不是函数,也不是方法,.比如`append,cap,len,make`这是一种语法特征

语法特征是高级语言提供的,内部帮你隐藏了如何分配内存等细节